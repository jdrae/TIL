# Spring 101

## SOLID - 객체 지향 설계의 5가지 원칙
* SRP 단일 책임 원칙, Single Responsibility Principle

    한 클래스는 하나의 책임만 가져야 한다. 클래스 책임의 범위는 너무 작아도, 너무 커도 안된다. 변경을 할 때 다른 클래스에 미치는 파급력이 적으면 적당한 책임이다.

* OCP 개방-폐쇄 원칙, Open/Closed Principle

    소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야한다. 다형성과 관련이 있는데, 인터페이스(부모)를 제대로 구현하면 클래스들(자식)에서 새로운 기능을 구현할 때 인터페이스 자체를 변경하지 않아도 된다. 

    하지만 `Fruit f = new Apple()` 이 있을 때 다른 클래스로 변경하려면 `Fruit f = new Orange()` 처럼 코드 자체를 변경해야한다. "변경에는 닫혀 있어야"하는 OCP 원칙을 지킬 수 없게 된다. 따라서 객체를 생성하고 관계를 맺는 별도의 설정자가 필요하다.

* LSP 리스코프 치환 원칙, Liskov Substitution Principle

    하위 클래스는 상위 인터페이스 규약을 다 지켜야한다. 정사각형은 직사각형에 포함되므로 직사각형 부모를 둔다고 하자. 이후 height 를 늘리는 함수를 제작한다면 직사각형 객체는 문제가 없지만 정사각형은 width 와 height 이 달라지므로 넓이를 계산할 때 문제가 생긴다. 따라서 정사각형과 직사각형은 치환이 되지 않으므로 상속 관계를 없애야 한다.

* ISP 인터페이스 분리 원칙, Interface Segregation Principle

    클라이언트가 자신이 이용하지 않는 메소드에 의존하지 않아야 한다. 자동차 인터페이스를 운전 인터페이스와 정비 인터페이스로 나눔으로써, 운전자 클라이언트와 정비사 클라이언트로 나뉘어지고 각각 독립적인 메소드를 사용하게 된다.

* DIP 의존관계 역전 원칙, Dependency Inversion Principle

    앞서 본 OCP 예제 `Fruit f = new Apple()` 는 Fruit 이 Apple 에 의존하고 있다. 이처럼 상위 모듈이 하위 모듈에 의존하는 관계를 역전해서, 하위 모듈의 구현으로부터 독립되게 할 수 있다. 즉, 상위 모듈은 하위 모듈에 의존해서는 안되고, 둘 다 추상화에 의존해야한다. 추상화 역시 세부사항에 의존해서는 안된다.